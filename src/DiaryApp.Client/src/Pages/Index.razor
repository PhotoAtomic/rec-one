@page "/"
@using Microsoft.JSInterop
@using System.Buffers
@inject IVideoCaptureService VideoCapture
@inject IVideoEntryClient EntryClient
@inject IJSRuntime JsRuntime
@implements IAsyncDisposable

<h1>Capture a new entry</h1>

<section class="capture-panel">
    <div class="capture-panel__content">
        <div class="capture-preview">
            <video class="capture-preview__video" @ref="_videoRef" playsinline muted></video>
            <div class="recording-monitor" aria-live="off">
                <span class="recording-monitor__label">Microphone level</span>
                <div class="vu-meter" @ref="_vuMeterRef" role="img" aria-label="Live microphone level meter">
                    <div class="vu-meter__fill" data-role="vu-fill"></div>
                </div>
            </div>
        </div>
        <div class="capture-actions">
            <button @onclick="StartRecording" disabled="@_isRecording">Start Recording</button>
            <button class="secondary" @onclick="StopRecording" disabled="@(!_isRecording)">Stop</button>
            <button type="button"
                    class="secondary"
                    @onclick="ToggleCaptureMode">
                @(_captureScreen ? "Use Webcam" : "Capture Screen")
            </button>
        </div>
    </div>
</section>

<EditForm Model="this" OnValidSubmit="SaveEntry">
    <div @ref="_formContainer">
    <input @bind="_title" placeholder="Entry title" @ref="_titleInput" />
    <textarea @bind="_description" placeholder="Description" rows="3"></textarea>
    <InputText @bind-Value="_tagInput" placeholder="Tags (comma separated)" />

    <button type="submit" disabled="@(!_hasRecording || _isSaving)" class="with-spinner">
        @if (_isSaving)
        {
            <span class="button-spinner" aria-hidden="true"></span>
            <span>Saving entry...</span>
        }
        else
        {
            <span>Save Entry</span>
        }
    </button>
    </div>
</EditForm>

@if (!string.IsNullOrWhiteSpace(_statusMessage))
{
    <p>@_statusMessage</p>
}

@if (_lastCreated is not null)
{
    <section @ref="_lastEntryRef">
        <h2>Last entry</h2>
        <p><strong>@_lastCreated.Title</strong></p>
        @if (!string.IsNullOrWhiteSpace(_lastCreated.Description))
        {
            <p>@_lastCreated.Description</p>
        }
        @if (_lastCreated.Summary is not null)
        {
            <p>@_lastCreated.Summary</p>
        }
        @if (_lastCreated.Tags.Any())
        {
            <p>Tags: @string.Join(", ", _lastCreated.Tags)</p>
        }
    </section>
}

@code {
    private const int ChunkSizeBytes = 5 * 1024 * 1024;

    private ElementReference _videoRef;
    private ElementReference _vuMeterRef;
    private bool _isRecording;
    private bool _hasRecording;
    private bool _isSaving;
    private string _title = string.Empty;
    private string _description = string.Empty;
    private string _tagInput = string.Empty;
    private string? _statusMessage;
    private VideoEntryDto? _lastCreated;
    private bool _captureScreen;
    private ElementReference _formContainer;
    private ElementReference _titleInput;
    private ElementReference _lastEntryRef;
    private IJSObjectReference? _uiModule;
    private bool _pendingScrollToLastEntry;

    private async Task StartRecording()
    {
        _statusMessage = null;
        _hasRecording = false;
        _isRecording = true;
        await VideoCapture.StartRecordingAsync(_videoRef, _vuMeterRef, _captureScreen);
    }

    private async Task StopRecording()
    {
        await VideoCapture.StopRecordingAsync();
        _isRecording = false;
        _hasRecording = true;
        await ScrollToFormAsync();
        await FocusTitleAsync();
    }

    private async Task SaveEntry()
    {
        if (!_hasRecording)
        {
            _statusMessage = "Record something before saving.";
            return;
        }

        _isSaving = true;
        _statusMessage = "Starting upload...";
        Guid? uploadId = null;
        byte[]? buffer = null;
        try
        {
            using var recordedStream = await VideoCapture.GetRecordedStreamAsync();
            if (recordedStream is null)
            {
                _statusMessage = "No recording available.";
                return;
            }

            recordedStream.Position = 0;

            if (!recordedStream.CanSeek || recordedStream.Length <= 0)
            {
                _statusMessage = "Recording is empty or not seekable.";
                return;
            }

            var totalBytes = recordedStream.Length;
            var safeTitle = string.IsNullOrWhiteSpace(_title) ? "untitled" : _title;
            var fileName = $"{safeTitle}.webm";

            var startResponse = await EntryClient.StartUploadAsync(
                new ChunkedUploadStartRequest(fileName, totalBytes));
            uploadId = startResponse.UploadId;

            buffer = ArrayPool<byte>.Shared.Rent(ChunkSizeBytes);
            var offset = 0L;
            int bytesRead;
            while ((bytesRead = await recordedStream.ReadAsync(buffer, 0, ChunkSizeBytes)) > 0)
            {
                using var chunkStream = new MemoryStream(buffer, 0, bytesRead, writable: false);
                await EntryClient.UploadChunkAsync(uploadId.Value, chunkStream, offset, totalBytes);
                offset += bytesRead;
                _statusMessage = $"Uploaded {offset / 1024 / 1024} MB of {Math.Max(totalBytes, offset) / 1024 / 1024} MB...";
                StateHasChanged();
            }

            var completeRequest = new ChunkedUploadCompleteRequest(_title, _description, _tagInput);
            _lastCreated = await EntryClient.CompleteUploadAsync(uploadId.Value, completeRequest);
            _pendingScrollToLastEntry = true;
            _statusMessage = "Entry saved.";
            _hasRecording = false;
        }
        catch (Exception ex)
        {
            if (uploadId.HasValue)
            {
                await EntryClient.CancelUploadAsync(uploadId.Value);
            }
            _statusMessage = $"Failed to save entry: {ex.Message}";
        }
        finally
        {
            if (buffer is not null)
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
            _isSaving = false;
        }
    }

    private async Task ScrollToFormAsync()
    {
        if (_formContainer.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _formContainer);
    }

    private async Task ScrollToLastEntryAsync()
    {
        if (_lastEntryRef.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _lastEntryRef);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingScrollToLastEntry)
        {
            _pendingScrollToLastEntry = false;
            await ScrollToLastEntryAsync();
        }
    }

    private async Task FocusTitleAsync()
    {
        if (_titleInput.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("focusElement", _titleInput);
    }

    private async Task EnsureUiModuleAsync()
    {
        _uiModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/uiHelpers.js");
    }

    public async ValueTask DisposeAsync()
    {
        if (_uiModule is not null)
        {
            await _uiModule.DisposeAsync();
        }
    }

    private async Task ToggleCaptureMode()
    {
        var nextMode = !_captureScreen;
        if (_isRecording)
        {
            try
            {
                await VideoCapture.SwitchCaptureAsync(_videoRef, _vuMeterRef, nextMode);
                _captureScreen = nextMode;
                _statusMessage = _captureScreen
                    ? "Switched to screen capture."
                    : "Switched to webcam capture.";
            }
            catch (Exception ex)
            {
                _statusMessage = $"Failed to switch capture mode: {ex.Message}";
            }
        }
        else
        {
            _captureScreen = nextMode;
            _statusMessage = _captureScreen
                ? "Screen capture enabled. Start recording to capture your display."
                : "Webcam capture enabled.";
        }
    }
}
