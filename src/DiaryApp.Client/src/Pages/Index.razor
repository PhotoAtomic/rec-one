@page "/"
@using Microsoft.JSInterop
@using System.IO
@using DiaryApp.Client.Services
@using Microsoft.AspNetCore.Components.Routing
@inject IVideoCaptureService VideoCapture
@inject VideoUploadService UploadService
@inject IOutgoingUploadQueue OutgoingQueue
@inject IDevicePreferencesService DevicePreferencesService
@inject IMediaSettingsClient MediaSettingsClient
@inject IJSRuntime JsRuntime
@inject NavigationManager Navigation
@implements IAsyncDisposable

<div class="page-header page-header--spaced">
    <h1>Capture a new entry</h1>
    <a href="/entries" class="go-to-entries-button" title="View entries" aria-label="View entries">
        <svg viewBox="0 0 36 24" class="go-to-entries-icon" aria-hidden="true">
            <!-- Book/diary icon -->
            <path d="M4 4h14c1 0 2 1 2 2v12c0 1-1 2-2 2H4c-1 0-2-1-2-2V6c0-1 1-2 2-2z" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M6 4v16" stroke="currentColor" stroke-width="1.5"/>
            <path d="M9 8h6M9 11h6M9 14h4" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
            <!-- Arrow pointing right -->
            <path d="M26 7l5 5-5 5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>

<section class="capture-panel">
    <div class="capture-panel__content">
        <div class="capture-preview">
            <video class="capture-preview__video @(_isMirrored && !_captureScreen ? "mirrored" : "") @(_isRecording && !_captureScreen ? "clickable" : "")" 
                   @ref="_videoRef" 
                   playsinline 
                   muted
                   @onclick="ToggleMirror"
                   title="@(_isRecording && !_captureScreen ? "Click to toggle mirror" : "")"></video>
            <div class="recording-monitor" aria-live="off">
                <span class="recording-monitor__label">Microphone level</span>
                <div class="vu-meter" @ref="_vuMeterRef" role="img" aria-label="Live microphone level meter">
                    <div class="vu-meter__fill" data-role="vu-fill"></div>
                </div>
            </div>
        </div>
        <div class="capture-actions">
            @if (!_isRecording && !_hasRecording)
            {
                <!-- Initial state: only Start button -->
                <button @onclick="StartRecording">Start Recording</button>
            }
            else if (_isRecording)
            {
                <!-- Recording state: Switch input + Stop -->
                @if (_canCaptureScreen)
                {
                    <button type="button"
                            class="secondary"
                            @onclick="ToggleCaptureMode">
                        @(_captureScreen ? "Use Webcam" : "Capture Screen")
                    </button>
                }
                <button @onclick="StopRecording">Stop</button>
            }
            else if (_hasRecording)
            {
                <!-- Post-recording state: Cancel + Save -->
                <button type="button" class="secondary" @onclick="CancelRecording">Cancel</button>
                <button type="submit" form="save-form" disabled="@_isSaving" class="with-spinner" @ref="_saveButton">
                    @if (_isSaving)
                    {
                        <span class="button-spinner" aria-hidden="true"></span>
                        <span>Saving...</span>
                    }
                    else
                    {
                        <span>Save</span>
                    }
                </button>
            }
        </div>
    </div>
</section>

<EditForm Model="this" OnValidSubmit="SaveEntry" id="save-form">
    <details @ref="_formContainer" open="@_detailsExpanded">
        <summary @onclick="ToggleDetails" @onclick:preventDefault>
            <svg class="details-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
            <span>Manual Details</span>
        </summary>
        <div class="details-content">
            <input @bind="_title" placeholder="Entry title" @ref="_titleInput" />
            <InputText @bind-Value="_tagInput" placeholder="Tags (comma separated)" />
            <textarea @bind="_description" placeholder="Description" rows="5"></textarea>
        </div>
    </details>
</EditForm>

@if (!string.IsNullOrWhiteSpace(_statusMessage))
{
    <p>@_statusMessage</p>
}

@code {
    private ElementReference _videoRef;
    private ElementReference _vuMeterRef;
    private bool _isRecording;
    private bool _hasRecording;
    private bool _isSaving;
    private string _title = string.Empty;
    private string _description = string.Empty;
    private string _tagInput = string.Empty;
    private string? _statusMessage;
    private bool _captureScreen;
    private bool _isMirrored = true;
    private ElementReference _formContainer;
    private ElementReference _titleInput;
    private ElementReference _saveButton;
    private IJSObjectReference? _uiModule;
    private IJSObjectReference? _permissionsModule;
    private bool _detailsExpanded = false;
    private bool _canCaptureScreen;
    private IJSObjectReference? _videoModule;

    protected override void OnInitialized()
    {
        Navigation.LocationChanged += HandleLocationChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await EnsureScreenCaptureCapabilityAsync();
        }
    }

    private void ToggleDetails()
    {
        _detailsExpanded = !_detailsExpanded;
    }

    private void ToggleMirror()
    {
        // Only allow toggling mirror when recording webcam (not screen capture)
        if (_isRecording && !_captureScreen)
        {
            _isMirrored = !_isMirrored;
        }
    }

    private async Task StartRecording()
    {
        _statusMessage = null;

        // Check if user needs to configure settings
        var settingsValid = await ValidateSettingsAsync();
        if (!settingsValid)
        {
            _statusMessage = "Please configure your audio/video devices and language settings before recording.";
            await Task.Delay(2000); // Give user time to read the message
            Navigation.NavigateTo("/settings");
            return;
        }

        _hasRecording = false;
        _isRecording = true;

        if (_captureScreen && !_canCaptureScreen)
        {
            _captureScreen = false;
        }
        
        try
        {
            await VideoCapture.StartRecordingAsync(_videoRef, _vuMeterRef, _captureScreen);
        }
        catch (Exception ex)
        {
            _statusMessage = $"Failed to start recording. Please check your camera and microphone settings: {ex.Message}";
            _isRecording = false;
            
            // Redirect to settings if there's a permission or device issue
            if (ex.Message.Contains("Permission") || ex.Message.Contains("NotAllowed") || ex.Message.Contains("denied"))
            {
                await Task.Delay(2000); // Give user time to read the message
                Navigation.NavigateTo("/settings");
            }
        }
    }

    private async Task<bool> ValidateSettingsAsync()
    {
        try
        {
            // Check device preferences (stored locally in browser)
            var devicePrefs = await DevicePreferencesService.GetDevicePreferencesAsync();
            var hasDevicesConfigured = !string.IsNullOrWhiteSpace(devicePrefs.CameraDeviceId) || 
                                      !string.IsNullOrWhiteSpace(devicePrefs.MicrophoneDeviceId);

            // Check server-side media preferences (language and tags)
            var mediaPrefs = await MediaSettingsClient.GetMediaPreferencesAsync();
            
            // Verify that the language has been explicitly set (not just the default)
            // We consider the settings valid if the user has kept the default language,
            // but we want to ensure they visited the settings page at least once
            var hasLanguageConfigured = !string.IsNullOrWhiteSpace(mediaPrefs.TranscriptLanguage);

            // Settings are valid if:
            // 1. At least one device (camera or microphone) is configured
            // 2. AND a transcript language is set (even if it's the default)
            return hasDevicesConfigured && hasLanguageConfigured;
        }
        catch (Exception ex)
        {
            _statusMessage = $"Failed to validate settings: {ex.Message}";
            return false;
        }
    }

    private async Task<bool> CheckIfNeedsDeviceSetupAsync()
    {
        try
        {
            // Check device preferences
            var devicePrefs = await DevicePreferencesService.GetDevicePreferencesAsync();
            var hasDevicesConfigured = !string.IsNullOrWhiteSpace(devicePrefs.CameraDeviceId) || 
                                      !string.IsNullOrWhiteSpace(devicePrefs.MicrophoneDeviceId);

            // Check media permissions
            _permissionsModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/mediaPermissions.js");
            var permissionCheck = await _permissionsModule.InvokeAsync<PermissionCheckResult>("checkMediaPermissions");

            // Redirect to settings if:
            // 1. No devices configured AND no permission granted yet
            // 2. OR explicitly needs permission (browser hasn't prompted yet)
            return (!hasDevicesConfigured && !permissionCheck.HasAccess) || permissionCheck.NeedsPermission;
        }
        catch (Exception)
        {
            // If check fails, allow recording attempt (will fail naturally and show error)
            return false;
        }
    }

    private async Task StopRecording()
    {
        await VideoCapture.StopRecordingAsync();
        _isRecording = false;
        _hasRecording = true;
        
        await ScrollToSaveButtonAsync();
        await FocusSaveButtonAsync();
    }

    private void CancelRecording()
    {
        // Reset all state to initial
        _hasRecording = false;
        _isRecording = false;
        _isSaving = false;
        _title = string.Empty;
        _description = string.Empty;
        _tagInput = string.Empty;
        _statusMessage = null;
        _captureScreen = false;
        _isMirrored = true;
        _detailsExpanded = false;
    }

    private async Task SaveEntry()
    {
        if (!_hasRecording)
        {
            _statusMessage = "Record something before saving.";
            return;
        }

        _isSaving = true;
        _statusMessage = "Preparing upload...";
        byte[]? recordingBytes = null;
        var safeTitle = string.IsNullOrWhiteSpace(_title) ? "untitled" : _title.Trim();
        try
        {
            recordingBytes = await ReadRecordingBytesAsync();
            if (recordingBytes is null || recordingBytes.Length == 0)
            {
                _statusMessage = "Recording is empty or unavailable.";
                return;
            }

            var fileName = $"{safeTitle}.webm";
            var progress = new Progress<UploadProgress>(p =>
            {
                var uploadedMb = p.UploadedBytes / 1024 / 1024;
                var totalMb = Math.Max(p.TotalBytes, p.UploadedBytes) / 1024 / 1024;
                _statusMessage = $"Uploaded {uploadedMb} MB of {totalMb} MB...";
                InvokeAsync(StateHasChanged);
            });

            await UploadService.UploadAsync(
                recordingBytes,
                fileName,
                _title,
                _description,
                _tagInput,
                progress);
            _hasRecording = false;
            
            // Redirect to entries page after successful save
            Navigation.NavigateTo("/entries");
        }
        catch (Exception ex)
        {
            _statusMessage = $"Failed to save entry: {ex.Message}";
            if (recordingBytes is not null && recordingBytes.Length > 0)
            {
                var queuedEntry = new OutgoingEntry(
                    new OutgoingEntryMetadata(
                        Guid.NewGuid(),
                        safeTitle,
                        _description,
                        _tagInput,
                        $"{safeTitle}.webm",
                        DateTimeOffset.UtcNow,
                        recordingBytes.LongLength),
                    recordingBytes);
                await OutgoingQueue.EnqueueAsync(queuedEntry);
                _statusMessage += " The recording was saved to the Outgoing queue.";
            }
        }
        finally
        {
            _isSaving = false;
        }
    }

    private async Task<byte[]?> ReadRecordingBytesAsync()
    {
        using var recordedStream = await VideoCapture.GetRecordedStreamAsync();
        if (recordedStream is null)
        {
            return null;
        }

        if (!recordedStream.CanRead)
        {
            return null;
        }

        using var memory = new MemoryStream();
        await recordedStream.CopyToAsync(memory);
        return memory.Length == 0 ? null : memory.ToArray();
    }

    private async Task ScrollToSaveButtonAsync()
    {
        // Small delay to ensure the button is rendered
        await Task.Delay(50);
        
        if (_saveButton.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _saveButton);
    }

    private async Task FocusSaveButtonAsync()
    {
        if (_saveButton.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("focusElement", _saveButton);
    }

    private async Task EnsureUiModuleAsync()
    {
        _uiModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/uiHelpers.js");
    }

    private async Task EnsureScreenCaptureCapabilityAsync()
    {
        var supported = false;
        try
        {
            _videoModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/videoRecorder.js");
            supported = await _videoModule.InvokeAsync<bool>("supportsScreenCapture");
        }
        catch (Exception ex)
        {
            supported = false;
        }

        if (_canCaptureScreen == supported)
        {
            return;
        }

        _canCaptureScreen = supported;
        if (!_canCaptureScreen && _captureScreen)
        {
            _captureScreen = false;
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        Navigation.LocationChanged -= HandleLocationChanged;

        if (_uiModule is not null)
        {
            await _uiModule.DisposeAsync();
        }
        if (_permissionsModule is not null)
        {
            await _permissionsModule.DisposeAsync();
        }
        if (_videoModule is not null)
        {
            await _videoModule.DisposeAsync();
        }
    }

    private async Task ToggleCaptureMode()
    {
        if (!_canCaptureScreen)
        {
            _statusMessage = "Screen capture is not supported on this device.";
            return;
        }

        var nextMode = !_captureScreen;
        if (_isRecording)
        {
            try
            {
                await VideoCapture.SwitchCaptureAsync(_videoRef, _vuMeterRef, nextMode);
                _captureScreen = nextMode;
                _statusMessage = _captureScreen
                    ? "Switched to screen capture."
                    : "Switched to webcam capture.";
            }
            catch (Exception ex)
            {
                _statusMessage = $"Failed to switch capture mode: {ex.Message}";
            }
        }
        else
        {
            _captureScreen = nextMode;
            _statusMessage = _captureScreen
                ? "Screen capture enabled. Start recording to capture your display."
                : "Webcam capture enabled.";
        }
    }

    private async void HandleLocationChanged(object? sender, LocationChangedEventArgs args)
    {
        if (!_isRecording)
        {
            return;
        }

        await StopAndDiscardRecordingAsync();
    }

    private async Task StopAndDiscardRecordingAsync()
    {
        try
        {
            await VideoCapture.StopRecordingAsync();
        }
        catch
        {
            // Ignore stop failures during navigation
        }
        finally
        {
            await InvokeAsync(() =>
            {
                CancelRecording();
                StateHasChanged();
            });
        }
    }

    private sealed class PermissionCheckResult
    {
        public bool HasAccess { get; set; }
        public bool NeedsPermission { get; set; }
    }
}
