@page "/"
@using Microsoft.JSInterop
@inject IVideoCaptureService VideoCapture
@inject IVideoEntryClient EntryClient
@inject IJSRuntime JsRuntime
@implements IAsyncDisposable

<h1>Capture a new entry</h1>

<section class="capture-panel">
    <div class="capture-panel__content">
        <div class="capture-preview">
            <video class="capture-preview__video" @ref="_videoRef" playsinline muted></video>
            <div class="recording-monitor" aria-live="off">
                <span class="recording-monitor__label">Microphone level</span>
                <div class="vu-meter" @ref="_vuMeterRef" role="img" aria-label="Live microphone level meter">
                    <div class="vu-meter__fill" data-role="vu-fill"></div>
                </div>
            </div>
        </div>
        <div class="capture-actions">
            <button @onclick="StartRecording" disabled="@_isRecording">Start Recording</button>
            <button class="secondary" @onclick="StopRecording" disabled="@(!_isRecording)">Stop</button>
            <button type="button"
                    class="secondary"
                    @onclick="ToggleCaptureMode">
                @(_captureScreen ? "Use Webcam" : "Capture Screen")
            </button>
        </div>
    </div>
</section>

<EditForm Model="this" OnValidSubmit="SaveEntry">
    <div @ref="_formContainer">
    <input @bind="_title" placeholder="Entry title" @ref="_titleInput" />
    <textarea @bind="_description" placeholder="Description" rows="3"></textarea>
    <InputText @bind-Value="_tagInput" placeholder="Tags (comma separated)" />

    <button type="submit" disabled="@(!_hasRecording || _isSaving)" class="with-spinner">
        @if (_isSaving)
        {
            <span class="button-spinner" aria-hidden="true"></span>
            <span>Saving entry...</span>
        }
        else
        {
            <span>Save Entry</span>
        }
    </button>
    </div>
</EditForm>

@if (!string.IsNullOrWhiteSpace(_statusMessage))
{
    <p>@_statusMessage</p>
}

@if (_lastCreated is not null)
{
    <section @ref="_lastEntryRef">
        <h2>Last entry</h2>
        <p><strong>@_lastCreated.Title</strong></p>
        @if (!string.IsNullOrWhiteSpace(_lastCreated.Description))
        {
            <p>@_lastCreated.Description</p>
        }
        @if (_lastCreated.Summary is not null)
        {
            <p>@_lastCreated.Summary</p>
        }
        @if (_lastCreated.Tags.Any())
        {
            <p>Tags: @string.Join(", ", _lastCreated.Tags)</p>
        }
    </section>
}

@code {
    private ElementReference _videoRef;
    private ElementReference _vuMeterRef;
    private bool _isRecording;
    private bool _hasRecording;
    private bool _isSaving;
    private string _title = string.Empty;
    private string _description = string.Empty;
    private string _tagInput = string.Empty;
    private string? _statusMessage;
    private VideoEntryDto? _lastCreated;
    private bool _captureScreen;
    private ElementReference _formContainer;
    private ElementReference _titleInput;
    private ElementReference _lastEntryRef;
    private IJSObjectReference? _uiModule;
    private bool _pendingScrollToLastEntry;

    private async Task StartRecording()
    {
        _statusMessage = null;
        _hasRecording = false;
        _isRecording = true;
        await VideoCapture.StartRecordingAsync(_videoRef, _vuMeterRef, _captureScreen);
    }

    private async Task StopRecording()
    {
        await VideoCapture.StopRecordingAsync();
        _isRecording = false;
        _hasRecording = true;
        await ScrollToFormAsync();
        await FocusTitleAsync();
    }

    private async Task SaveEntry()
    {
        if (!_hasRecording)
        {
            _statusMessage = "Record something before saving.";
            return;
        }

        _isSaving = true;
        _statusMessage = "Uploading entry...";

        try
        {
            using var recordedStream = await VideoCapture.GetRecordedStreamAsync();
            if (recordedStream is null)
            {
                _statusMessage = "No recording available.";
                return;
            }

            recordedStream.Position = 0;

            using var content = new MultipartFormDataContent();
            var streamContent = new StreamContent(recordedStream);
            streamContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("video/webm");
            var safeTitle = string.IsNullOrWhiteSpace(_title) ? "untitled" : _title;
            content.Add(streamContent, "file", $"{safeTitle}.webm");
            content.Add(new StringContent(_title), "title");
            content.Add(new StringContent(_description ?? string.Empty), "description");
            content.Add(new StringContent(_tagInput ?? string.Empty), "tags");

            _lastCreated = await EntryClient.CreateAsync(content);
            _pendingScrollToLastEntry = true;
            _statusMessage = "Entry saved.";
            _hasRecording = false;
        }
        catch (Exception ex)
        {
            _statusMessage = $"Failed to save entry: {ex.Message}";
        }
        finally
        {
            _isSaving = false;
        }
    }

    private async Task ScrollToFormAsync()
    {
        if (_formContainer.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _formContainer);
    }

    private async Task ScrollToLastEntryAsync()
    {
        if (_lastEntryRef.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _lastEntryRef);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingScrollToLastEntry)
        {
            _pendingScrollToLastEntry = false;
            await ScrollToLastEntryAsync();
        }
    }

    private async Task FocusTitleAsync()
    {
        if (_titleInput.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("focusElement", _titleInput);
    }

    private async Task EnsureUiModuleAsync()
    {
        _uiModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/uiHelpers.js");
    }

    public async ValueTask DisposeAsync()
    {
        if (_uiModule is not null)
        {
            await _uiModule.DisposeAsync();
        }
    }

    private async Task ToggleCaptureMode()
    {
        var nextMode = !_captureScreen;
        if (_isRecording)
        {
            try
            {
                await VideoCapture.SwitchCaptureAsync(_videoRef, _vuMeterRef, nextMode);
                _captureScreen = nextMode;
                _statusMessage = _captureScreen
                    ? "Switched to screen capture."
                    : "Switched to webcam capture.";
            }
            catch (Exception ex)
            {
                _statusMessage = $"Failed to switch capture mode: {ex.Message}";
            }
        }
        else
        {
            _captureScreen = nextMode;
            _statusMessage = _captureScreen
                ? "Screen capture enabled. Start recording to capture your display."
                : "Webcam capture enabled.";
        }
    }
}
