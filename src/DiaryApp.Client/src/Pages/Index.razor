@page "/"
@using Microsoft.JSInterop
@using System.IO
@using DiaryApp.Client.Services
@inject IVideoCaptureService VideoCapture
@inject VideoUploadService UploadService
@inject IOutgoingUploadQueue OutgoingQueue
@inject IJSRuntime JsRuntime
@implements IAsyncDisposable

<h1>Capture a new entry</h1>

<section class="capture-panel">
    <div class="capture-panel__content">
        <div class="capture-preview">
            <video class="capture-preview__video" @ref="_videoRef" playsinline muted></video>
            <div class="recording-monitor" aria-live="off">
                <span class="recording-monitor__label">Microphone level</span>
                <div class="vu-meter" @ref="_vuMeterRef" role="img" aria-label="Live microphone level meter">
                    <div class="vu-meter__fill" data-role="vu-fill"></div>
                </div>
            </div>
        </div>
        <div class="capture-actions">
            <button @onclick="StartRecording" disabled="@_isRecording">Start Recording</button>
            <button class="secondary" @onclick="StopRecording" disabled="@(!_isRecording)">Stop</button>
            <button type="button"
                    class="secondary"
                    @onclick="ToggleCaptureMode">
                @(_captureScreen ? "Use Webcam" : "Capture Screen")
            </button>
        </div>
    </div>
</section>

<EditForm Model="this" OnValidSubmit="SaveEntry">
    <div @ref="_formContainer">
    <input @bind="_title" placeholder="Entry title" @ref="_titleInput" />
    <textarea @bind="_description" placeholder="Description" rows="3"></textarea>
    <InputText @bind-Value="_tagInput" placeholder="Tags (comma separated)" />

    <button type="submit" disabled="@(!_hasRecording || _isSaving)" class="with-spinner">
        @if (_isSaving)
        {
            <span class="button-spinner" aria-hidden="true"></span>
            <span>Saving entry...</span>
        }
        else
        {
            <span>Save Entry</span>
        }
    </button>
    </div>
</EditForm>

@if (!string.IsNullOrWhiteSpace(_statusMessage))
{
    <p>@_statusMessage</p>
}

@if (_lastCreated is not null)
{
    <section @ref="_lastEntryRef">
        <h2>Last entry</h2>
        <p><strong>@_lastCreated.Title</strong></p>
        @if (!string.IsNullOrWhiteSpace(_lastCreated.Description))
        {
            <p>@_lastCreated.Description</p>
        }
        @if (_lastCreated.Summary is not null)
        {
            <p>@_lastCreated.Summary</p>
        }
        @if (_lastCreated.Tags.Any())
        {
            <p>Tags: @string.Join(", ", _lastCreated.Tags)</p>
        }
    </section>
}

@code {
    private ElementReference _videoRef;
    private ElementReference _vuMeterRef;
    private bool _isRecording;
    private bool _hasRecording;
    private bool _isSaving;
    private string _title = string.Empty;
    private string _description = string.Empty;
    private string _tagInput = string.Empty;
    private string? _statusMessage;
    private VideoEntryDto? _lastCreated;
    private bool _captureScreen;
    private ElementReference _formContainer;
    private ElementReference _titleInput;
    private ElementReference _lastEntryRef;
    private IJSObjectReference? _uiModule;
    private bool _pendingScrollToLastEntry;

    private async Task StartRecording()
    {
        _statusMessage = null;
        _hasRecording = false;
        _isRecording = true;
        await VideoCapture.StartRecordingAsync(_videoRef, _vuMeterRef, _captureScreen);
    }

    private async Task StopRecording()
    {
        await VideoCapture.StopRecordingAsync();
        _isRecording = false;
        _hasRecording = true;
        await ScrollToFormAsync();
        await FocusTitleAsync();
    }

    private async Task SaveEntry()
    {
        if (!_hasRecording)
        {
            _statusMessage = "Record something before saving.";
            return;
        }

        _isSaving = true;
        _statusMessage = "Preparing upload...";
        byte[]? recordingBytes = null;
        var safeTitle = string.IsNullOrWhiteSpace(_title) ? "untitled" : _title.Trim();
        try
        {
            recordingBytes = await ReadRecordingBytesAsync();
            if (recordingBytes is null || recordingBytes.Length == 0)
            {
                _statusMessage = "Recording is empty or unavailable.";
                return;
            }

            var fileName = $"{safeTitle}.webm";
            var progress = new Progress<UploadProgress>(p =>
            {
                var uploadedMb = p.UploadedBytes / 1024 / 1024;
                var totalMb = Math.Max(p.TotalBytes, p.UploadedBytes) / 1024 / 1024;
                _statusMessage = $"Uploaded {uploadedMb} MB of {totalMb} MB...";
                InvokeAsync(StateHasChanged);
            });

            _lastCreated = await UploadService.UploadAsync(
                recordingBytes,
                fileName,
                _title,
                _description,
                _tagInput,
                progress);
            _pendingScrollToLastEntry = true;
            _statusMessage = "Entry saved.";
            _hasRecording = false;
        }
        catch (Exception ex)
        {
            _statusMessage = $"Failed to save entry: {ex.Message}";
            if (recordingBytes is not null && recordingBytes.Length > 0)
            {
                var queuedEntry = new OutgoingEntry(
                    new OutgoingEntryMetadata(
                        Guid.NewGuid(),
                        safeTitle,
                        _description,
                        _tagInput,
                        $"{safeTitle}.webm",
                        DateTimeOffset.UtcNow,
                        recordingBytes.LongLength),
                    recordingBytes);
                await OutgoingQueue.EnqueueAsync(queuedEntry);
                _statusMessage += " The recording was saved to the Outgoing queue.";
            }
        }
        finally
        {
            _isSaving = false;
        }
    }

    private async Task<byte[]?> ReadRecordingBytesAsync()
    {
        using var recordedStream = await VideoCapture.GetRecordedStreamAsync();
        if (recordedStream is null)
        {
            return null;
        }

        if (!recordedStream.CanRead)
        {
            return null;
        }

        using var memory = new MemoryStream();
        await recordedStream.CopyToAsync(memory);
        return memory.Length == 0 ? null : memory.ToArray();
    }

    private async Task ScrollToFormAsync()
    {
        if (_formContainer.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _formContainer);
    }

    private async Task ScrollToLastEntryAsync()
    {
        if (_lastEntryRef.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("scrollIntoView", _lastEntryRef);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingScrollToLastEntry)
        {
            _pendingScrollToLastEntry = false;
            await ScrollToLastEntryAsync();
        }
    }

    private async Task FocusTitleAsync()
    {
        if (_titleInput.Context is null)
        {
            return;
        }

        await EnsureUiModuleAsync();
        await _uiModule!.InvokeVoidAsync("focusElement", _titleInput);
    }

    private async Task EnsureUiModuleAsync()
    {
        _uiModule ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/uiHelpers.js");
    }

    public async ValueTask DisposeAsync()
    {
        if (_uiModule is not null)
        {
            await _uiModule.DisposeAsync();
        }
    }

    private async Task ToggleCaptureMode()
    {
        var nextMode = !_captureScreen;
        if (_isRecording)
        {
            try
            {
                await VideoCapture.SwitchCaptureAsync(_videoRef, _vuMeterRef, nextMode);
                _captureScreen = nextMode;
                _statusMessage = _captureScreen
                    ? "Switched to screen capture."
                    : "Switched to webcam capture.";
            }
            catch (Exception ex)
            {
                _statusMessage = $"Failed to switch capture mode: {ex.Message}";
            }
        }
        else
        {
            _captureScreen = nextMode;
            _statusMessage = _captureScreen
                ? "Screen capture enabled. Start recording to capture your display."
                : "Webcam capture enabled.";
        }
    }
}
